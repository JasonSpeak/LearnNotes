- [命名规则](#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99)
- [类型、存储、变量](#%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E5%8F%98%E9%87%8F)
- [类、方法](#%E7%B1%BB%E6%96%B9%E6%B3%95)
- [继承、多态](#%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81)
- [表达式和运算符](#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)
- [结构](#%E7%BB%93%E6%9E%84)
- [委托](#%E5%A7%94%E6%89%98)
- [事件](#%E4%BA%8B%E4%BB%B6)
- [接口](#%E6%8E%A5%E5%8F%A3)
- [转换](#%E8%BD%AC%E6%8D%A2)
- [泛型](#%E6%B3%9B%E5%9E%8B)
- [多线程处理](#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86)
- [异步编程](#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B)
- [CLI && GC](#CLI--GC)


***
***
### 命名规则
> * 参数使用驼峰命名法
> * 其余命名均使用帕斯卡命名法
> * 属性和关联字段命名：关联字段使用驼峰命名法，属性使用帕斯卡命名法

### 类型、存储、变量
> * 类型是模板，需要实例化才能使用
> * dynamic 动态类型
> * C#中数值类型不具有bool意义
> * 除了16种预定义类型，还有6种可以自定义的类型
>   + 类 (class)
>   + 结构 (struct)
>   + 数组 (array)
>   + 枚举 (enum)
>   + 委托 (delegate)
>   + 接口 (interface)
> * 引用类型的所有数据成员都在堆里
> * 匿名类型(var)需要属性名称、数据类型、属性顺序都完全相同才能“类型兼容”
> * 匿名类型(var)是只读的，一旦实例化就不可变


### 类、方法
> * 访问控制有5种
>   + private:仅该类内部可访问
>   + public：任何类均可访问
>   + protected：所有继承该类的类可访问
>   + internal：仅该程序集 **(.dll && .exe)** 内所有类可访问
>   + protected internal：继承该类的类或该程序集内的类可访问
> * 类的成员默认为private，也可以显式声明，public必须显式声明
> * var关键字
>   + 只能在方法里使用，不能用于字段
>   + 只能在变量声明中包含初始化的时候使用(编译器可以推断出类型)
> * 引用参数 **ref**，输出参数 **out**
> * 属性：一般用来控制外部访问 private 字段，通过get和set的访问器来控制
> * get和set的访问级别可以不同，例如get为public，set为private，就可以设置为外部可读取但不可修改
> * 构造函数可以被重载，从而可以创建不一样的实例
> * **readonly** 与 const 类似，const必须在字段的声明语句中初始化，readonly可以在构造函数中再初始化

### 继承、多态
> * 派生类可以使用 new 关键词屏蔽基类的成员、基类可以通过 base 关键词访问被屏蔽的基类成员
> * 可以通过virtual和override覆写基类的成员
> * abstract关键词修饰抽象类和抽象方法
>   + 抽象类不能被实例化
>   + 抽象类必须被继承
>   + 抽象方法必须在派生类中实现
>   + 数据成员不可以声明为abstract
> * 密封类不可被继承，以 sealed 关键词修饰
> * 静态类所有成员都是静态的，用于存放不受实例影响的数据和函数
>   + 静态类使用static标记
>   + 可以有静态构造函数，但不能实例化
>   + 不可继承

### 表达式和运算符
> * 字符串前加 @ ，不解析转义字符
> * 赋值运算符、比较运算符、逻辑运算符、位运算符

### 结构
> * 结构声明时不允许初始化字段
> * 结构不能被继承

### 委托
> * 类似cpp函数指针，可以动态选择要运行的函数。
> * 对C#委托[较好的解释](https://blog.csdn.net/nicolas_li/article/details/8455754)
> * [C#中Lambda表达式](https://www.w3cschool.cn/csharp/csharp-lambda-expressions.html)

### 事件
> * 类似于委托，事件被触发时执行委托的函数列表
> * 使用标准事件 Eventhandler 处理委托，需要两个参数EventHandler(**object sender,EventArgs e**)
> * 拓展EventArgs来向事件的委托函数传递参数
> * 发布者在适当处使用事件，订阅者在代码中声明事件处理方法，并在需要获得通知的地方订阅事件。

### 接口
> * 可以实现原生接口来使自己的类拥有原生的功能，例如sort
> * 接口的声明不能有数据成员和静态成员，只能声明**方法、属性、事件、索引器**
> * 一个类可以继承并实现多个接口
> * 接口可以继承接口

### 转换
> * 可以使用 **checked** 和 **unchecked** 语句来检测转换溢出
> * 装箱&拆箱
>   + 装箱：值类型转换为引用类型
>   + 拆箱：引用类型转换为值类型（试图转换为非原始类型会报错）
> * 使用 **is** 运算符检测转换是否可行（只可用于引用转换、装箱/拆箱转换）
> * 自定义转换，即自定义的类或结构与其他类型之间的转换，需使用 **implicit**
> * **as** 运算符是作用类似强制转换，返回引用类型（只可用于引用转换和装箱转换）

### 泛型
> * 泛型是类的模板，对参数类型宽容，具体使用时确定参数类型
> * 泛型中的类型参数，可以使用 **where** 子句进行约束，从而确定可接受的参数类型,约束类型有：
>   + 类名：约束为该类及其子类
>   + class: 约束为任何引用类型，例如类，数组，委托，接口
>   + struct: 约束为值类型
>   + 接口名：约束为这个接口及其实现类
>   + new(): 又名 **构造函数约束**，约束为带有无参公共构造函数的类型
> * 约束顺序为：主约束(类名，class，struct)、接口约束、new()
> * 可空类型，通过 **?** 运算符将值类型装箱为可空类型
> * 处理可空变量的空值，通过 **??** 运算符将可能为空值的可空变量赋初值
> * 对于可能返回空值的方法，可以使用 **?.** 运算符将该方法的返回值装箱为可空类型

### 多线程处理
> - 多线程复杂的复杂性在于：
>   - 监视异步操作的状态，需要知道它在何时完成（最好不要采取轮询线程状态的方法，也不要采取阻塞等待的方法）
>   - 线程池(线程池避免了启动和终止线程的巨大开销，也避免了创建大量的线程，防止系统花在切换线程上的时间过多)
>   - 避免死锁(防止数据同时被两个不同的线程访问)
>   - 为不同的操作提供原子性并同步数据访问(为不同的操作组提供同步，可以确保将一系列操作作为整体来执行，并且可由另一个线程恰当的中端，锁定机制防止两个不容的线程同时访问数据)
> - 尽量规避在生产代码中使用Thread.Sleep()
> - 在生产代码中不要终止线程Thread.Abort()
> - 使用线程池能够有效提高多线程的执行效率，效率是通过重用线程(而不是每个异步调用都重新构造线程)获得的
> - [yield return关键词](https://my.oschina.net/huxuanhui/blog/33285)：提供了迭代器一个比较重要的功能，即取到一个数据后马上返回该数据，不需要全部数据装入数列完毕，这样有效提高了遍历效率。


### 异步编程
> * 由 **async/await** 关键词修饰
> - 写异步方法命名约定需要在方法名最后加 **Async**
> * **async**修饰方法名，**await**修饰方法中需要异步执行的任务
> * 需要得到异步方法的返回值，使用 **Task < T >**，仅需要检查异步方法状态则使用 **Task**,仅执行异步代码则使用 **void**
> * **Task < T >** 返回的是类型为 **T** 的值，使用 **Task.Result** 获取值
> * await后的异步任务需要返回 **awaitable** 类型，一般使用 **Task.Run(Func< TReturn >  func), Task.Run**的参数是一个委托
> * **Task.Delay( )** 延迟异步方法,实现GUI编程中的异步问题
> * **[Task.Yield( )](https://stackoverflow.com/questions/22645024/when-would-i-use-task-yield)**：保存当前函数上下文(就是保存了当前函数运行到了什么地方),然后退出当前函数返回到调用点，然后再到这个函数中继续执行
> * 异步编程模式
>   + 等待-直到结束模式:开始异步->完成其他简单处理->停止等待异步结束
>   + 轮询模式：开始异步->查询异步是否完成，未完成则进行其他处理->异步完成
>   + 回调模式：开始异步->初始线程继续处理->异步方法结束，自行调用结果处理函数
>   + 定时重复运行异步方法，Timer类
> - 避免程序在任何线程上产生未处理异常
> - **Parallel**: 并行计算
>   - **parallel.For(fromInclusive , toExclusive , Action < T > )**
>   - 可以通过使用ParallelOptions对象对Parallel进行控制  
>  **eg：Parallel.ForEach( param, parallelOptions, Action < T >)**
>   - 使用Parallel并行执行Linq查询  
> **IEnumerable< T > data;  
>   data.AsParallel( ).Select()**



### CLI && GC
> * CLI：公共语言基础结构
> * CIL: 公共中间语言
> * VES: 运行时（虚拟执行系统）
> * C#代码--->(C#编译器)--->CIL--->(JIT)--->机器码




